# Hash & Lineage Constitution  ## Purpose  This document defines the canonical rules for hashing, lineage tracking, and generational identity across all files, sections, and extracted artifacts in the RegScriptBox ecosystem.  Hashing is used for: - Identity - Change detection - Lineage tracing - De-duplication - Standardization enforcement  Hashing is NOT used for: - Security - Encryption - Access control  This system is deterministic, transparent, and fully reconstructible.   ## Core Principles  1. Hashes represent **code reality**, not intent. 2. Lineage is **single-parent**, never multi-parent. 3. Only non–Generation-0 artifacts carry lineage hashes. 4. No artifact ever stores grandparent lineage directly. 5. Full lineage reconstruction is achieved by recursive resolution.   ## Definitions  ### Content Hash A deterministic hash generated from normalized source content.  Used to: - Detect identical or variant implementations - Anchor identity of a specific version  ### Lineage Hash A hash derived from the **parent PYN**, used to trace origin.  Used to: - Track derivation - Reconstruct ancestry - Distinguish forks and generations   ## Generational Model  ### Generation 0 (Gen0) - Original tools or files - Not derived from another PYN - Contains:   - Its own content hash   - NO lineage hash  ### Generation N (Gen1+) - Derived via extraction, standardization, or synthesis - Contains:   - Its own content hash   - A lineage hash referencing the parent PYN   ## Hash Composition Rules  ### Content Hash Generated from: - Normalized code body - Ignoring:   - Whitespace-only changes   - Comments   - Formatting differences  Algorithm: - Stable, deterministic (e.g. SHA-256 or equivalent) - Same input MUST always yield same hash   ### Lineage Hash Generated from: - The parent artifact's **PYN string**, not its raw code  This ensures: - Lineage tracks identity, not implementation noise - Parent changes automatically propagate lineage meaning   ## Storage Rules  ### In-File Storage - Content hashes MAY appear in metadata headers - Lineage hashes MUST NOT appear inside section headers  ### Registry Storage The registry stores: - Content hash - Lineage hash (if any) - Generation number - Parent PYN reference   ## Reconstruction Rule  To reconstruct lineage: 1. Read the lineage hash 2. Resolve it to the parent PYN 3. Inspect the parent PYN's lineage hash 4. Repeat until a Gen0 artifact is reached  This forms a complete, auditable ancestry chain.   ## Mutation Rules  - Any code change produces a NEW content hash - Any new extraction produces a NEW PYN - Standardization MAY:   - Replace multiple SIDs with one   - Invalidate obsolete hashes - Obsolete hashes remain in registry history but are never reused   ## Non-Goals  This system does NOT attempt to: - Merge multiple parents into one lineage - Preserve deprecated implementations - Optimize for human memorization  It optimizes for: - Machine reasoning - Deterministic behavior - Long-term scalability   ## Lock Status  This constitution is LOCKED.  Changes require: - Explicit version bump - Recorded rationale - Migration rules for existing registry entries
# Hash & Lineage Constitution  ## Purpose  This document defines the canonical rules for hashing, lineage tracking, and generational identity across all files, sections, and extracted artifacts in the RegScriptBox ecosystem.  Hashing is used for: - Identity - Change detection - Lineage tracing - De-duplication - Standardization enforcement  Hashing is NOT used for: - Security - Encryption - Access control  This system is deterministic, transparent, and fully reconstructible.   ## Core Principles  1. Hashes represent **code reality**, not intent. 2. Lineage is **single-parent**, never multi-parent. 3. Only non–Generation-0 artifacts carry lineage hashes. 4. No artifact ever stores grandparent lineage directly. 5. Full lineage reconstruction is achieved by recursive resolution.   ## Definitions  ### Content Hash A deterministic hash generated from normalized source content.  Used to: - Detect identical or variant implementations - Anchor identity of a specific version  ### Lineage Hash A hash derived from the **parent PYN**, used to trace origin.  Used to: - Track derivation - Reconstruct ancestry - Distinguish forks and generations   ## Generational Model  ### Generation 0 (Gen0) - Original tools or files - Not derived from another PYN - Contains:   - Its own content hash   - NO lineage hash  ### Generation N (Gen1+) - Derived via extraction, standardization, or synthesis - Contains:   - Its own content hash   - A lineage hash referencing the parent PYN   ## Hash Composition Rules  ### Content Hash Generated from: - Normalized code body - Ignoring:   - Whitespace-only changes   - Comments   - Formatting differences  Algorithm: - Stable, deterministic (e.g. SHA-256 or equivalent) - Same input MUST always yield same hash   ### Lineage Hash Generated from: - The parent artifact's **PYN string**, not its raw code  This ensures: - Lineage tracks identity, not implementation noise - Parent changes automatically propagate lineage meaning   ## Storage Rules  ### In-File Storage - Content hashes MAY appear in metadata headers - Lineage hashes MUST NOT appear inside section headers  ### Registry Storage The registry stores: - Content hash - Lineage hash (if any) - Generation number - Parent PYN reference   ## Reconstruction Rule  To reconstruct lineage: 1. Read the lineage hash 2. Resolve it to the parent PYN 3. Inspect the parent PYN's lineage hash 4. Repeat until a Gen0 artifact is reached  This forms a complete, auditable ancestry chain.   ## Mutation Rules  - Any code change produces a NEW content hash - Any new extraction produces a NEW PYN - Standardization MAY:   - Replace multiple SIDs with one   - Invalidate obsolete hashes - Obsolete hashes remain in registry history but are never reused   ## Non-Goals  This system does NOT attempt to: - Merge multiple parents into one lineage - Preserve deprecated implementations - Optimize for human memorization  It optimizes for: - Machine reasoning - Deterministic behavior - Long-term scalability   ## Lock Status  This constitution is LOCKED.  Changes require: - Explicit version bump - Recorded rationale - Migration rules for existing registry entries
# Hash & Lineage Constitution  ## Purpose  ## Definitions  ## Hash Generation Rules  ## Lineage Rules  ## Generation Zero Rules  ## Constraints  ## Non-Goals

